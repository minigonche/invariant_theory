-- Script for final project of Invariant Theory
-- Authors: Daniel De Roux
			Felipe Gonzalez 

-- Our field will be the rational numbers, since fractions are only implemented
--	for ZZ, QQ and finite fields
-- WARNING! For the methods: createTMatrix, molienTerm and molienTeo, this variable cannot
--			be overwritten, our else we cannot add the final polinomial fractions

R = QQ[t];

-- ## FUNCTIONS ## --
-- Function that constructs an n x n  identity matrix with the variable 't', corresponding to the ring 
--		R = QQ[t] declared before. (I'm sure there is an easier way to do this but I could not find it)
-- Returns: an n x n identity matrix with the variable 't' on the diagonal

createTMatrix = n -> (
	-- Constructs using a double loop
    w := t;
	m := for j from 1 to n list
		(for i from 1 to n  list w 
			do if i > j then w = 0 
        	else if i == j - 1 then w = t 
        	else w = 0);
      matrix(m)
);



-- Function that returns the fraction part of the Invariant's Hilbert Series, using Molien.
-- Inputs: A (matrix): corresponds to the image of a given "g" inside the Group under rho.
--                     the matrix need to be over the complex filed
-- Returns: 1/(det(I - t*A^{-1}))

molienTerm = A -> ( 
	I := id_(QQ^(numgens target A)); -- Identity Matrix	
	T :=  createTMatrix(numgens target A); -- Diagonal t Matrix 	
	A1 := inverse(A); -- Inverse of matrix A
	final := I - T*A;
	1/det(final)
);



-- Function that receives a list of matrices and calculates the Hilbert Series of the invariant ring
--	using the Molien Theorem
-- Inputs: matrixList (List of Matrices): In order for this method to work, each  matrix needs to be 
-- over QQ 
-- Returns: Hilbert Series (using Molien Theorem)

molienTeo = matrixList -> (
	n := length(matrixList); --Number of matrices
	-- first saves each term on a list
	all := for i from 0 to (n-1) list molienTerm(matrixList_i);
	HS := sum(all)/n;
	HS
);


-- Auxiliary method for calculating list of options given a matrix and a list of variables
-- Inputs:  A (matrix) matrix that will be applyed to the variables
--			varList (list of variables) the list of varaibles
-- Returns: list of options representating the effect of the matrix A over the variables varList

applyMatrixToVars = (A, varList) -> (	
	varMatrix := transpose(matrix({varList})); -- Verival vector of variables
	result := A*varMatrix; -- Aplies transformation
	-- Assignes options
	listOptions := for i from 0 to (length(varList) - 1) list varList_i => result_0_i ;
	listOptions
);


-- Function that calculates the Rayleigh operator for a given polinomial.
-- Inputs:  f (polinomial) a polinomial expression.
--			varList (list of varibles) the list of variables. They must be the same variables of f.
--			matrixList (List of Matrices): list of matrices corresponding to rho(g), where g is an 
--										   element of the Group and rho its representation.
-- Returns: polinomial corresponding to the image of the Rayleigh operator

rayleighOperator = (f, varList, matrixList) -> (
	n := length(matrixList); --Number of matrices
	-- Calculates the inverse of each matrix
	inverseList := for i from 0 to (n-1) list inverse(matrixList_i); 
	-- Calculates the list of options options for each matrix
	allOptions := for i from 0 to (n-1) list applyMatrixToVars(matrixList_i, varList);
	allApplications := for i from 0 to (n-1) list sub(f, allOptions_i);
	finalPol := sum(allApplications)/n;
	finalPol
);

-- Function that calculates the Rayleigh operator for a list of given polinomials.
-- Inputs:  listOfPolynomials (list of polinomials) a list of polinomial expressions.
--			varList (list of varibles) the list of variables. They must be the same variables of f.
--			matrixList (List of Matrices): list of matrices corresponding to rho(g), where g is an 
--										   element of the Group and rho its representation.
-- Returns: list of polinomials corresponding to the image of the Rayleigh operator

rayleighOperatorList = (listOfPolynomials, varList, matrixList) -> (
	totPol := length(listOfPolynomials); -- Number of polynomials
	result:= for i from 0 to (totPol-1) list rayleighOperator(listOfPolynomials_i, varList, matrixList);
	result
);



-- Function that that constructs a graded polyomial ring with n free variables and returns a list 
-- with the basis for each degree of the graded ring until d. The ring will have variables x_i so the 
-- y should be unused. 
-- Inputs: 	n (integer > 0) the number of variables the ring will have
--			d (inetger > 0) the mas number of dimension for the basis
-- Returns: a tuple:
--			1. The list of variables of the ring
--			2. A list who's ith entry correspond to the set of polynomials of degree i, that form a
-- 			   basis for ith coordinate of the graded ring.

getGradedBasis = (n, d) -> (
	RTemp := QQ[x_1..x_n];
	basisList := for i from 0 to d list flatten(entries(basis(i,RTemp)));
	result = { gens(RTemp) , basisList};
	result
);



-- Function that given a set of matrices, constructs a list of invariant polynomials for each degree, 
-- using the Rayleigh operator. This method assumes that all matrices are square, have rational 
-- entries, are invertable and have the same dimensions. We also assume that there is a matrix for
-- each element of the underlying group
-- Inputs:  matrixList (List of Matrices): list of matrices corresponding to rho(g), where g is an 
-- element of the Group and rho its representation.
-- Returns: List of oplynoimals where the entry i correspond to a list with invariant polinomials of 
-- degree i.

getInvariantPolinomials = matrixList -> (
	-- Extracts the dimension of the gradient ring (number of columns of the matrices)
	n := numgens target matrixList_0;
	d := length(matrixList); -- Size of the group
	temp := getGradedBasis(n,d);
	varList:= temp_0; -- The list of varaibles
	gradedBasis := temp_1; -- The basis for each grade of the ring
	result := for i from 0 to d list rayleighOperatorList(gradedBasis_i, varList, matrixList);
	result
);			


















